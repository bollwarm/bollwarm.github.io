<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>工具 &#8211; 虫虫之家</title>
	<atom:link href="/?feed=rss2&#038;cat=7" rel="self" type="application/rss+xml" />
	<link></link>
	<description>略懂技术</description>
	<lastBuildDate>Sat, 01 Mar 2025 15:25:16 +0000</lastBuildDate>
	<language>zh-Hans</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.7.2</generator>
	<item>
		<title>数字电路到可消化胶囊机器人，细数麻省理工改变世界的伟大发明</title>
		<link>/?p=1082</link>
					<comments>/?p=1082#respond</comments>
		
		<dc:creator><![CDATA[lin123]]></dc:creator>
		<pubDate>Wed, 27 Feb 2019 02:00:00 +0000</pubDate>
				<category><![CDATA[云计算&容器]]></category>
		<category><![CDATA[工具]]></category>
		<category><![CDATA[编程]]></category>
		<category><![CDATA[自动化&DevOPs&SRE]]></category>
		<category><![CDATA[设计]]></category>
		<category><![CDATA[资料]]></category>
		<category><![CDATA[随感]]></category>
		<guid isPermaLink="false">/?p=1082</guid>

					<description><![CDATA[大家都知道麻省理工MIT是世界数一数二的大学，更是计算机技术科学界的翘楚。去年麻省理工又投资十亿美刀建立苏世民 [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p></p>



<p>大家都知道麻省理工MIT是世界数一数二的大学，更是计算机技术科学界的翘楚。去年麻省理工又投资十亿美刀建立苏世民（Stephen A. Schwarzman）计算机学院。在最近院庆活动中，麻省了推出了其CS科技成果展，罗列了一些了伟大的发明包括了数字电路到可可消化胶囊肠壁治疗机器人。本文虫虫和大家一起来看看麻省这些改变世界的伟大发明。</p>



<span id="more-1082"></span>



<h2 class="wp-block-heading">1937年</h2>



<h3 class="wp-block-heading">数字电路</h3>



<p>1937年克劳德·香农（Claude Elwood Shannon）在麻省发表硕士论文《A Symbolic Analysis of Relay and Switching Circuits》（继电器与开关电路的符号分析）：真/假逻辑的原理可以用来代表电气开关的开关状态。该论文开创了数字电路领域的基础，是整个数字行业，计算机的基础。基于该开创新的发现及后续一系列的理论，克劳德·香农被称为信息论之父。</p>



<figure class="wp-block-image size-full"><img fetchpriority="high" decoding="async" width="455" height="276" src="/wp-content/uploads/2025/03/1-5.png" alt="" class="wp-image-1084" srcset="/wp-content/uploads/2025/03/1-5.png 455w, /wp-content/uploads/2025/03/1-5-300x182.png 300w" sizes="(max-width: 455px) 100vw, 455px" /></figure>



<h2 class="wp-block-heading">上世纪40年代</h2>



<h3 class="wp-block-heading">数字计算机</h3>



<p>世界上第一台可以实时运行的数字计算机来自旋风计划（Project Whirlwind）。这是二战期间的一项军方研究，1944年由麻省理工学院与美国海军合作开发完成旋风机器人，用于通用飞行模拟。该计划成功导致了世界上第一胎可实时运行的数字计算机旋风计算机，也为后续1951年麻省理工学院林肯实验室的成立奠定了基础。</p>



<figure class="wp-block-image size-full"><img decoding="async" width="557" height="321" src="/wp-content/uploads/2025/03/2-4.png" alt="" class="wp-image-1085" srcset="/wp-content/uploads/2025/03/2-4.png 557w, /wp-content/uploads/2025/03/2-4-300x173.png 300w" sizes="(max-width: 557px) 100vw, 557px" /></figure>



<h3 class="wp-block-heading">Memex数据系统</h3>



<p>Vannevar Bush教授1945年发表论文《As We May Think》提出了一个名为“Memex”的“扩展存储器（Memory-Extender）” 数据系统。该系统设想可以用来“存储用户所有的书籍，记录和通信信息”并能随意检索它们。这个概念启发了早期的超文本系统，正是由于系统的产生和繁荣，启发了几十年后万维网的诞生。</p>



<figure class="wp-block-image size-full"><img decoding="async" width="716" height="390" src="/wp-content/uploads/2025/03/3-4.png" alt="" class="wp-image-1086" srcset="/wp-content/uploads/2025/03/3-4.png 716w, /wp-content/uploads/2025/03/3-4-300x163.png 300w, /wp-content/uploads/2025/03/3-4-624x340.png 624w" sizes="(max-width: 716px) 100vw, 716px" /></figure>



<h2 class="wp-block-heading">上世纪50年代</h2>



<h3 class="wp-block-heading">函数式编程语言LISP</h3>



<p>第一种函数式编程语言LISP是由John McCarthy教授于1958年在麻省理工发明的。在LISP之前，基于功能事的编程很难同时处理多个进程。函数式编程可让您更简单地描述所需的行为，从而可以处理比以往更大的问题。LISP诞生带动了大量的语言产生比如Clojure,&nbsp;Scala,&nbsp;Erlang,&nbsp;Haskell和 Elixir等，甚至在当今的编程语言中，增加函数式功能也还是个热点。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="594" height="274" src="/wp-content/uploads/2025/03/4-3.png" alt="" class="wp-image-1087" srcset="/wp-content/uploads/2025/03/4-3.png 594w, /wp-content/uploads/2025/03/4-3-300x138.png 300w" sizes="auto, (max-width: 594px) 100vw, 594px" /></figure>



<h3 class="wp-block-heading">实时传真</h3>



<p>1959年麻省理工学院的学生Sam Asano发明了一种通过电话线传输扫描材料的​​技术，可以让你的听到声音的同时也能看到画面。但是该发明并未引起重视，日本电信公司NTT收购，NTT认为可以用来代替发电报，因为写下了传输图形，敲打字符要来的快。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="512" height="240" src="/wp-content/uploads/2025/03/5-4.png" alt="" class="wp-image-1088" srcset="/wp-content/uploads/2025/03/5-4.png 512w, /wp-content/uploads/2025/03/5-4-300x141.png 300w" sizes="auto, (max-width: 512px) 100vw, 512px" /></figure>



<h2 class="wp-block-heading">上世纪60年代</h2>



<h3 class="wp-block-heading">多人制视频游戏</h3>



<p>麻省理工电气工程系气采购了PDP-1计算机首先被用来不是计算，而是被一群贪玩的学生用来打游戏了。1962年Marvin Minsky AI团队的学生Steven “Slug” Russell和游友们一起开发了一款空战视频游戏“SpaceWar!”，并在码农中广为流行，这是世界上第一款多人制游戏。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="597" height="437" src="/wp-content/uploads/2025/03/6-4.png" alt="" class="wp-image-1089" srcset="/wp-content/uploads/2025/03/6-4.png 597w, /wp-content/uploads/2025/03/6-4-300x220.png 300w" sizes="auto, (max-width: 597px) 100vw, 597px" /></figure>



<h3 class="wp-block-heading">CTSS、Multics和密码</h3>



<p>我们每天都要和密码打交道，密码是保障我们安全的最重要的屏障。而密码的发明也是来自于麻省理工。世界上第一个使用密码的系统是麻省理工学院的分时系统CTSS，弗尔南多考巴托（Fernando Jose Corbato） 教授于1963年在开发CTSS时候发明了密码，当时系统为了实现一个多终端，多用户，又互相隔离，每个用户自有文件目录，通过密码来区别用户成了简便快捷的解决方案。需要提及的是CTSS系统和后续的Multics，为Ken Thompson和Dennis Ritchie开发UNIX操作系统奠定了基础。考巴托教授因为这些突出的贡献于1990年被授予了计算机图灵奖 。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="564" height="370" src="/wp-content/uploads/2025/03/7-2.png" alt="" class="wp-image-1090" srcset="/wp-content/uploads/2025/03/7-2.png 564w, /wp-content/uploads/2025/03/7-2-300x197.png 300w" sizes="auto, (max-width: 564px) 100vw, 564px" /></figure>



<h3 class="wp-block-heading">图形用户界面</h3>



<p>麻省理工的Ivan Sutherland博士生已经有了直接与电脑屏幕连接的想法，在前面提到的Memex系统的启发下，他于1963年开发“Sketchpad”系统，允许用户使用触摸笔绘制几何形状，开创了“计算机辅助绘图”的先河！</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="488" height="300" src="/wp-content/uploads/2025/03/8-2.png" alt="" class="wp-image-1091" srcset="/wp-content/uploads/2025/03/8-2.png 488w, /wp-content/uploads/2025/03/8-2-300x184.png 300w" sizes="auto, (max-width: 488px) 100vw, 488px" /></figure>



<h3 class="wp-block-heading">阿波罗导航系统</h3>



<p>1969年玛格丽特.汉密尔顿（Margaret Hamilton）率领麻省理工学院的团队编写了阿波罗11号导航系统，该系统辅助宇航员Neil Armstrong和 Buzz Aldrin成功登月。系统功能强大，还覆盖了将飞行器计算机执行指令，比如从优先系统到雷达系统的切换等，更值得称道的的该系统在载人登月的阿波罗登月计划任务中始终未出现任何bug。汉密尔顿作为码农中的巾帼好英雄在2016年被奥巴马总统亲自颁发了自由总统自由勋章。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="576" height="486" src="/wp-content/uploads/2025/03/9-2.png" alt="" class="wp-image-1092" srcset="/wp-content/uploads/2025/03/9-2.png 576w, /wp-content/uploads/2025/03/9-2-300x253.png 300w" sizes="auto, (max-width: 576px) 100vw, 576px" /></figure>



<h2 class="wp-block-heading">上世纪70年代</h2>



<h3 class="wp-block-heading">电子邮件Email</h3>



<p>1971年麻省理工校友Ray Tomlinson发送了第一封通过计算机网络传递的电子邮件。他在BBN Technologies工作时，创造了Email，也是第一个使用@的人。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="531" height="295" src="/wp-content/uploads/2025/03/10-3.png" alt="" class="wp-image-1093" srcset="/wp-content/uploads/2025/03/10-3.png 531w, /wp-content/uploads/2025/03/10-3-300x167.png 300w" sizes="auto, (max-width: 531px) 100vw, 531px" /></figure>



<h3 class="wp-block-heading">个人电脑</h3>



<p>麻省理工教授Butler Lampson教授创立了施乐公司施乐帕克（Xerox Palo Alto）研究中心研究中心（PARC）。由于突出性研究工作，使Lampson教授赢得了“现代PC之父”的称号。1973年PARC创造世界上第一台个人电脑奥拓（Alto）。在奥拓电脑上有了世界上第一个图形用户界面（GUI），第一个位图显示，以及第一个“所见即所得”（WYSIWYG）编辑器。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="374" height="435" src="/wp-content/uploads/2025/03/11-3.png" alt="" class="wp-image-1094" srcset="/wp-content/uploads/2025/03/11-3.png 374w, /wp-content/uploads/2025/03/11-3-258x300.png 258w" sizes="auto, (max-width: 374px) 100vw, 374px" /></figure>



<h3 class="wp-block-heading">数据加密</h3>



<p>1977年麻省理工团队在发明电子商务时候，发明了数据加密的RSA算法，RSA算法是一种非对称加密算法，它基于大质数的因数分解的困难度，来保证RSA的可靠性。</p>



<p>该算法在虫虫之前的文章中曾今介绍过，大家可以关注虫虫，从历史文章中查看详情介绍。</p>



<p>RSA算发的名字也是来自于麻省理工的三个发明人罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）的名字，取他们名字的第一个字母就是RSA。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="422" height="222" src="/wp-content/uploads/2025/03/12-3.png" alt="" class="wp-image-1095" srcset="/wp-content/uploads/2025/03/12-3.png 422w, /wp-content/uploads/2025/03/12-3-300x158.png 300w" sizes="auto, (max-width: 422px) 100vw, 422px" /></figure>



<h3 class="wp-block-heading">电子表格</h3>



<p>1979年，Bob Frankston和Dan Brickson在麻省理工的大型机上工作夜以继日的工作，并创造了世界上第一个电子表格系统VisiCalc。VisiCalc一出世就受到广泛好评，第一年就卖出了超10万份的拷贝。有意思的是，VisiCalc还是推动苹果AppleⅡ电脑的大卖，因为当时VisiCalc和AppleⅡ是捆绑销售的。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="434" height="287" src="/wp-content/uploads/2025/03/13-1.png" alt="" class="wp-image-1096" srcset="/wp-content/uploads/2025/03/13-1.png 434w, /wp-content/uploads/2025/03/13-1-300x198.png 300w" sizes="auto, (max-width: 434px) 100vw, 434px" /></figure>



<h2 class="wp-block-heading">上世纪80年代</h2>



<h3 class="wp-block-heading">以太网</h3>



<p>通过以太网技术可让我们通过简单的电缆插件就可以联网。以太网技术的发明源于麻省理工校友鲍勃.梅特卡夫Bob Metcalfe。他曾在1973年了一篇有关以太网潜力的备忘录，1979他和助手一起发表了论文《以太网：局域计算机网络的分布式包交换技术》为以太网的诞生奠定了理论基础。1980梅特卡夫创建了3com公司，3com公司联合DEC、英特尔和施乐一起起早指定了太网标准化规范标志着以太网的正式诞生。由于以太网的发展和促进，才有了后来互联网的飞速发展和流行。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="488" height="362" src="/wp-content/uploads/2025/03/14-1.png" alt="" class="wp-image-1097" srcset="/wp-content/uploads/2025/03/14-1.png 488w, /wp-content/uploads/2025/03/14-1-300x223.png 300w" sizes="auto, (max-width: 488px) 100vw, 488px" /></figure>



<h3 class="wp-block-heading">光学鼠标</h3>



<p>麻省理工本科生史蒂夫.基尔希（Steve Kirsch）于1980年第一个申请了光学计算机鼠标专利。他设想使用最少的精密移动部件制作一个“点设备”，为此，他创立了鼠标系统公司。他还发明了跟踪方法专利，通过点击计数来计算在线广告展示次数。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="354" height="266" src="/wp-content/uploads/2025/03/15-1.png" alt="" class="wp-image-1098" srcset="/wp-content/uploads/2025/03/15-1.png 354w, /wp-content/uploads/2025/03/15-1-300x225.png 300w" sizes="auto, (max-width: 354px) 100vw, 354px" /></figure>



<h3 class="wp-block-heading">自由软件的兴起</h3>



<p>黑客文化和自由软件运动的主要先驱麻省AI实验室的Richard Stallman教父于1983年发起了GNU（GNU代表“GNU&#8217;s Not Unix”）计划，项目旨在开发Unix操作系统的免费替代品，GUN项目开发GCC、GDB、Gxxx等以G开头的自由软件。也为GNU/Linux操作系统和其他重要的计算创新奠定了基础。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="510" height="301" src="/wp-content/uploads/2025/03/16-1.png" alt="" class="wp-image-1099" srcset="/wp-content/uploads/2025/03/16-1.png 510w, /wp-content/uploads/2025/03/16-1-300x177.png 300w" sizes="auto, (max-width: 510px) 100vw, 510px" /></figure>



<h3 class="wp-block-heading">生成树算法</h3>



<p>Radia Perlman 是码农界的又一女豪杰，具有 “互联网之母”之称。她于1985年开发了生成树算法是全球计算机网络数据传输路由的基础。该算法将以太网从原始有限可扩展的单线CSMA/CD转换为可处理大型网络的协议，并使以太网可极大地利用带宽。路由生成树算法对互联网数据传输产生了深远影响，提高了整改互联网的鲁棒性，从此，互联网具具有了自我管理和可扩展的特性。</p>



<p>值得提及的是她还创建了LOGO，这是第一种面向儿童的编程语言。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="636" height="393" src="/wp-content/uploads/2025/03/17-1.png" alt="" class="wp-image-1100" srcset="/wp-content/uploads/2025/03/17-1.png 636w, /wp-content/uploads/2025/03/17-1-300x185.png 300w, /wp-content/uploads/2025/03/17-1-624x386.png 624w" sizes="auto, (max-width: 636px) 100vw, 636px" /></figure>



<h2 class="wp-block-heading">上世纪90年代</h2>



<h3 class="wp-block-heading">万维网联盟（W3C）</h3>



<p>WWW之父Tim Berners-Lee在发明Web之后，于1994年加入麻省理工并成立了一个致力于建立全球标准的互联网联盟，为建站、浏览器和设备提供服务，这就是W3C的来历。W3C标准用于构建可访问，安全，并可以轻松被搜索引擎优化(SEO)的网站标准。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="579" height="356" src="/wp-content/uploads/2025/03/18-1.png" alt="" class="wp-image-1101" srcset="/wp-content/uploads/2025/03/18-1.png 579w, /wp-content/uploads/2025/03/18-1-300x184.png 300w" sizes="auto, (max-width: 579px) 100vw, 579px" /></figure>



<h3 class="wp-block-heading">区块链的诞生</h3>



<p>1999年麻省理工教授Barbara Liskov的发表了关于实用拜占庭容错算法（PBFT： Practical Byzantine Fault Tolerance）论文奠定了区块链的理论基础，并生成了第一个区块链，这是一种广泛使用的密码系统。利斯科夫教授团队的区块链系统可以处理高吞吐量的事务，还首创了很多当今区块链平台至关重要的概念。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="684" height="298" src="/wp-content/uploads/2025/03/19-1.png" alt="" class="wp-image-1102" srcset="/wp-content/uploads/2025/03/19-1.png 684w, /wp-content/uploads/2025/03/19-1-300x131.png 300w, /wp-content/uploads/2025/03/19-1-624x272.png 624w" sizes="auto, (max-width: 684px) 100vw, 684px" /></figure>



<h2 class="wp-block-heading">近20年</h2>



<h3 class="wp-block-heading">Roomba扫地机器人</h3>



<p>Colin Angle在读本科的时候加入了AI 实验室，在实验室时他萌生了让机器人能够和真实的环境进行实时反馈的想法，他开发了一款可移动机器人GenghiS。Genghis仿生了蚂蚁的灵感，他的导师是著名的机器人之父 Rodney Brooks教授。1990年， Colin Angle和导师 Rodney 教授同学 Helen Greiner 一起创办了机器人公司 iRobot。iRobot创建很多NB的机器人，比如火星车火星（漫游者Sojourner Rover），但是他的商业模式都不是很成功，直到2002年Roomba的推出，对，就是它，没有腿的机器人。截止目前Roomba扫地人已售出超2000万台，并催生了整个自动化清洁产品行业。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="529" height="352" src="/wp-content/uploads/2025/03/20-1.png" alt="" class="wp-image-1103" srcset="/wp-content/uploads/2025/03/20-1.png 529w, /wp-content/uploads/2025/03/20-1-300x200.png 300w" sizes="auto, (max-width: 529px) 100vw, 529px" /></figure>



<h3 class="wp-block-heading">移动个人助理</h3>



<p>大家都知道苹果的Siri和亚马逊的Alexa。但是，很早之前就有了这样的系统。2007年麻省理工的教授Boris Katz就开发了StartMobile，一款可进行约会安排，信获取息以及使用语音完成各类任务的APP。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="985" height="449" src="/wp-content/uploads/2025/03/21.png" alt="" class="wp-image-1104" srcset="/wp-content/uploads/2025/03/21.png 985w, /wp-content/uploads/2025/03/21-300x137.png 300w, /wp-content/uploads/2025/03/21-768x350.png 768w, /wp-content/uploads/2025/03/21-624x284.png 624w" sizes="auto, (max-width: 985px) 100vw, 985px" /></figure>



<h3 class="wp-block-heading">EdX在线开放课堂</h3>



<p>由前CSAIL主管Anant Agarwal领导，2012年麻省理工联合哈佛大学开办了大规模在线开放课堂平台EdX，通过该EdX提供免费的在线课程。截止目前EdX免费在线课程已经吸引了全球逾1800万学习者。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="736" height="477" src="/wp-content/uploads/2025/03/22.png" alt="" class="wp-image-1105" srcset="/wp-content/uploads/2025/03/22.png 736w, /wp-content/uploads/2025/03/22-300x194.png 300w, /wp-content/uploads/2025/03/22-624x404.png 624w" sizes="auto, (max-width: 736px) 100vw, 736px" /></figure>



<h3 class="wp-block-heading">可消化胶囊机器人</h3>



<p>麻省计算机科学与人工智能实验室（CSAIL）Daniela Rus于2016年等开发了可消化折叠胶囊机器人，可将其吞咽到肠胃，预热可从胶囊状自动展开，可以在体外磁场控制它攀爬你的胃壁，修复伤口，去除结石和误吞咽下去的异物等。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="620" height="335" src="/wp-content/uploads/2025/03/23.png" alt="" class="wp-image-1106" srcset="/wp-content/uploads/2025/03/23.png 620w, /wp-content/uploads/2025/03/23-300x162.png 300w" sizes="auto, (max-width: 620px) 100vw, 620px" /></figure>



<h2 class="wp-block-heading">波士顿动力</h2>



<p>Marc Raibert教授于1992年创建了波士顿动力公司。该公司制造了让人们大饱眼福的“大狗”，“Atlas”， “SpotMini”等机器人明星，可以攀爬，跑步，跳跃，甚至可以进行翻转。其中Atlas被用于DARPA机器人挑战赛，取得很棒的成绩。2013年波士顿动力公司被谷歌收购，2017年波士顿动力再次易主被日本软银收归旗下。</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="531" height="319" src="/wp-content/uploads/2025/03/24.png" alt="" class="wp-image-1107" srcset="/wp-content/uploads/2025/03/24.png 531w, /wp-content/uploads/2025/03/24-300x180.png 300w" sizes="auto, (max-width: 531px) 100vw, 531px" /></figure>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=1082</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>vim RE 非贪婪匹配</title>
		<link>/?p=808</link>
					<comments>/?p=808#respond</comments>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Tue, 25 Aug 2015 09:18:13 +0000</pubDate>
				<category><![CDATA[vim]]></category>
		<category><![CDATA[RE]]></category>
		<guid isPermaLink="false">/?p=770</guid>

					<description><![CDATA[/a.{-}b 它会匹配到&#8221;axbxb&#8221;中的&#8221;axb&#8221;. 如果 [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>/a.{-}b<br />
它会匹配到&#8221;axbxb&#8221;中的&#8221;axb&#8221;. 如果模式是:<br />
normal mode command<br />
/a.*b<br />
它就会尽可能多地匹配了. 所以匹配到的是整个&#8221;axbxb&#8221;.</p>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=808</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Linux 命令行邮件工具&#8211;mail</title>
		<link>/?p=751</link>
					<comments>/?p=751#respond</comments>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Thu, 16 Jul 2015 13:34:13 +0000</pubDate>
				<category><![CDATA[shell]]></category>
		<category><![CDATA[工具]]></category>
		<guid isPermaLink="false">/?p=751</guid>

					<description><![CDATA[1. 最简单的一个例子： mail -s test admin@ijz.me 这条命令的结果是发一封标题为te [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>1. 最简单的一个例子：</p>
<p>mail -s test admin@ijz.me</p>
<p>这条命令的结果是发一封标题为test的空信给后面的邮箱，如果你有mta并且后面的邮箱不会挡这种可能莫名奇妙的信的时候，就能收到这封信了。如果你不想被这种乱七八糟的事情干扰，后面的邮箱请使用本地帐户。<span id="more-751"></span></p>
<p>2. 第二个例子：</p>
<p>三种常用格式发信</p>
<p>mail -s test admin@ijz.me</p>
<p>#第一种方法，你可以把当前shell当成编辑器来用，编辑完内容后Ctrl-D结束</p>
<p>echo “mail content”|mail -s test admin@ijz.me</p>
<p>#第二种方法，我用的最多，可能是喜欢管道的缘故吧</p>
<p>mail -s test yangfang@fudan.edu.cn &lt; file</p>
<p>#第三种方法，以file的内容为邮件内容发信</p>
<p>其实你很容易发现mail从标准输入读取文件内容并发信，我也只想让你知道这一点，到此，第二个例子结束。</p>
<p>3. 第三个例子，带附件的邮件</p>
<p>如果你的系统里没有uuencode命令的话，请先安装sharutils(yum install sharutils)</p>
<p>uuencode 需要两个参数，第一个是你要发送的文件(们)，当然这个也可以用管道来做，第二个是显示的文件名</p>
<p>uuencode /tmp/a.gif a.gif|mail -s pictest admin@ijz.me</p>
<p>tar czf &#8211; /tmp/ | uuencode tmp.tar.gz |mail -s pictest admin@ijz.me</p>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
系统收到邮件都会保存在“/var/spool/mail/[linux用户名]”文件中。<br />
在linux中输入mail，就进行了收件箱，并显示二十封邮件列表。<br />
此时命令提示符为&#8221;&amp;&#8221;<br />
unread 标记为未读邮件<br />
<strong>h|headers 显示当前的邮件列表</strong><br />
l|list 显示当前支持的命令列表<br />
?|help 显示多个查看邮件列表的命令参数用法<br />
<strong>d 删除当前邮件，指针并下移。 d 1-100 删除第1到100封邮件</strong><br />
f|from 只显示当前邮件的简易信息。 f num 显示某一个邮件的简易信息<br />
f|from num 指针移动到某一封邮件<br />
z 显示刚进行收件箱时的后面二十封邮件列表<br />
more|p|page 阅读当前指针所在的邮件内容 阅读时，按空格键就是翻页，按回车键就是下移一行<br />
t|type|more|p|page num 阅读某一封邮件<br />
n|next|{什么都不填} 阅读当前指针所在的下一封邮件内容,阅读时，按空格键就是翻页，按回车键就是下移一行<br />
v|visual 当前邮件进入纯文本编辑模式<br />
<strong>n|next|{什么都不填} num 阅读某一封邮件</strong><br />
top 显示当前指针所在的邮件的邮件头<br />
file|folder 显示系统邮件所在的文件，以及邮件总数等信息<br />
x 退出mail命令平台，并不保存之前的操作，比如删除邮件<br />
q 退出mail命令平台,保存之前的操作，比如删除已用d删除的邮件，已阅读邮件会转存到当前用户家目录下的mbox文件中。如果在mbox中删除文件才会彻底删除。<br />
在linux文本命令平台输入 mail -f mbox，就可以看到当前目录下的mbox中的邮件了。<br />
cd 改变当前所在文件夹的位置<br />
写信时，连按两次Ctrl+C键则中断工作，不送此信件。<br />
读信时，按一次Ctrl+C，退出阅读状态。</p>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=751</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>nohup, setsid, &#038;, disown, screen&#8211;Linux进程任务控制</title>
		<link>/?p=722</link>
					<comments>/?p=722#respond</comments>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Wed, 25 Mar 2015 01:41:11 +0000</pubDate>
				<category><![CDATA[linux]]></category>
		<category><![CDATA[工具]]></category>
		<guid isPermaLink="false">/?p=722</guid>

					<description><![CDATA[              用ssh登录了远程的Linux服务器，运行了一些耗时较长的任务，结果却由于网络等的 [&#8230;]]]></description>
										<content:encoded><![CDATA[<div>
<div>
<p>              用ssh登录了远程的Linux服务器，运行了一些耗时较长的任务，结果却由于网络等的不稳定导致任务中途失败。这是由于在用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。<br />
解决办法有两种：让进程忽略HUP信号，或让进程运行在新的会话里从而成为不属于此终端的子进程。<br />
<span id="more-722"></span><br />
&nbsp;</p>
<p>下面是对Linux下运行与控制后台进程的各种方法的介绍：<br />
<strong>1.nohup</strong><br />
顾名思义，nohup的用途就是让提交的命令忽略所有的hangup信号。<br />
使用方法：nohup COMMAND [ARG]&#8230;</p>
<p><strong>2.setsid</strong><br />
在一个新的会话中运行命令，从而可以避开当前终端发出的HUP信号。<br />
使用方法：setsid COMMAND [ARG]&#8230;</p>
<p><strong>3.&amp;</strong><br />
可以结合()产生一个新的子shell并在这个子shell中将任务放置到后台运行，从而不受当前shell终端的HUP信号影响。<br />
使用方法：(COMMAND [ARG]&#8230; &amp;)</p>
<p>而我通常的使用方式为：<br />
nohup ./filename.sh &gt; filename.log 2&gt;&amp;1 &amp;<br />
三点理由:<br />
1)nohup保障进程不会被hangup信号异常中断；<br />
2)将任务放置到后台运行，不占用当前的终端；<br />
3)将错误输出也打印到log中，默认&gt;只有标准输出，错误输出没有。<br />
<strong>4.控制进程</strong><br />
通过以下命令，我们可以对放入到后台的命令进行控制</p>
<p>查看当前终端下的后台进程：<br />
直接执行：jobs</p>
<p>将查看到的某个后台进程放回到前台：<br />
直接输入：fg {jobid} //这里的{jobid}是通过jobs命令中看到的进程前[]中的数字。</p>
<p>将当前正在前台运行的进程放到后台运行:<br />
先敲下快捷键：ctrl +z //暂停当前正在运行的进程。<br />
再执行：bg</p>
<p>终止当前正在前台运行的进程：<br />
直接敲下快捷键：ctrl +c</p>
<p><strong>5.disown</strong><br />
亡羊补牢，为没有使用nohup与setsid的进程加上忽略HUP信号的功能。<br />
使用方法：<br />
将当前正在前台运行的进程放到后台运行（ctrl+z和bg）;<br />
然后执行disown -h %{jobid} //这里的{jobid}是通过jobs命令中看到的进程前[]中的数字。</p>
<p><strong>6.通过screen来实现稳定的后台运行</strong><br />
screen 是建立一个新的全屏虚拟会话终端，这个会话只有在手动输入exit的时候才会退出，在这个会话里执行的命令不用担心HUP信号会对我们的进程造成影响，因 此也不用给每个命令前都加上“nohup”或“setsid”了，非常适合我们有规划的执行大量的后台任务，可以非常方便的让我们对这些后台任务进行管 理。</p>
<p>使用方法：<br />
screen //立即创建并进入一个会话。<br />
screen -dmS {name} //建立一个处于断开模式下的会话，并根据我们的需要指定其会话名称。<br />
screen -list //列出所有会话。<br />
screen -r {name} //进入指定会话。<br />
ctrl +ad //输入快捷键ctrl +a和d，可暂时退出当前会话。<br />
exit //进入指定会话后执行exit即可关闭该会话。</p>
<p>参考资料：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/">https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/</a></p>
</div>
</div>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=722</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Linux用vim/vi给文件加密和解密/zz/</title>
		<link>/?p=692</link>
					<comments>/?p=692#respond</comments>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Mon, 24 Nov 2014 04:16:58 +0000</pubDate>
				<category><![CDATA[vim]]></category>
		<category><![CDATA[安全]]></category>
		<guid isPermaLink="false">/?p=692</guid>

					<description><![CDATA[linux文件为了防止被人随便打开收看，可以使用那个vim自带的加密功能，对文本文件进行加密，以防止人直接看到 [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>linux文件为了防止被人随便打开收看，可以使用那个vim自带的加密功能，对文本文件进行加密，以防止人直接看到内容。</p>
<p>然而在使用Vim编辑文件保存时时，有时候可能输入:X（shift键未及时按下松开），这时体统会提示：</p>
<p><span id="more-692"></span></p>
<blockquote><p><strong>Enter encryption key:</strong></p></blockquote>
<p>原来:X命令是加密文本的命令。根据提示输入密钥，然后会再次提示：</p>
<blockquote><p><strong>Enter same key again:</strong></p></blockquote>
<p>加密后的文本需要密钥才可查看。</p>
<p>有加密就需要有取消加密，取消密钥需在打开文件后（如果文件已加密，当然<strong>需要先输入密钥才能进行如下操作</strong>）</p>
<p>在命令行模式下：</p>
<blockquote><p><strong>: set key= </strong></p></blockquote>
<p><strong>将密钥赋值为空（必须要有空格）即可。</strong></p>
<p>问题是vim是如何加密文件的？答案是vim采用了BlowFish加密算法（7.3版本），密钥存储在key这个选项中。</p>
<p>实际操作的过程中还遇到一个问题，在设置加密密钥后保存文件，只有用:wq才可以，用:x不可以。看了这两个命令不是完全等价的，查看帮助文档发现：:wq是将缓冲区中的内容写入文件，而:x则需要缓冲区内容被修改时才会将缓冲区中的内容写入文件。</p>
<p>由此看来设置密钥不会改变缓冲区的内容，缓冲区的内容就不会被加密存入文件了。</p>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=692</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>VSFTP配置虚拟用户/zz/</title>
		<link>/?p=688</link>
					<comments>/?p=688#respond</comments>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Fri, 21 Nov 2014 07:14:20 +0000</pubDate>
				<category><![CDATA[工具]]></category>
		<category><![CDATA[ftp]]></category>
		<guid isPermaLink="false">/?p=688</guid>

					<description><![CDATA[     虚拟用户的特点是只能访问服务器为其提供的FTP服务，而不能访问系统的其它资源。所以，如果想让用户对F [&#8230;]]]></description>
										<content:encoded><![CDATA[<h1 class="postTitle"></h1>
<div id="cnblogs_post_body">
<p>     虚拟用户的特点是只能访问服务器为其提供的FTP服务，而不能访问系统的其它资源。所以，如果想让用户对FTP服务器站内具有写权限，但又不允许访问系统其它资源，可以使用虚拟用户来提高系统的安全性。</p>
<p>在VSFTP中，认证这些虚拟用户使用的是单独的口令库文件（pam_userdb），由可插入认证模块（PAM）认证。使用这种方式更加安全，并且配置更加灵活。<br />
下面介绍配置过程。<br />
<span id="more-688"></span><br />
1．生成虚拟用户口令库文件。为了建立此口令库文件，先要生成一个文本文件。该文件的格式如下，单数行为用户名，偶数行为口令：</p>
<p>#vi account.txt<br />
ylg<br />
1234<br />
zhanghong<br />
4321<br />
gou<br />
5678</p>
<p>2．生成口令库文件，并修改其权限：</p>
<p>#db_load -T -t hash -f ./account.txt /etc/vsftpd/account.db<br />
#chmod 600 /etc/vsftpd/account.db</p>
<p>3．新建一个虚拟用户的PAM文件。加上如下两行内容：</p>
<p>#vi /etc/pam.d/vsftp.vu<br />
auth required /lib/security/pam_userdb.so db=/etc/vsftpd/account<br />
account required /lib/security/pam_userdb.so db=/etc/vsftpd/account</p>
<p>4．建立虚拟用户，设置该用户所要访问的目录，并设置虚拟用户访问的权限：</p>
<p>#useradd -d /home/ftpsite virtual_user<br />
#chmod 700 /home/ftpsite</p>
<p>经过该步骤的设置，/home/ftpsite就是virtual_user用户的主目录，该用户也是ftpsite目录的拥有者。除root用户之外，只有该用户具有对该目录的读、写和执行的权限。<br />
5．编辑/etc/vsftpd/vsftpd.conf文件，使其整个文件内容如下所示（去掉了注释内容）：</p>
<p>anonymous_enable=NO<br />
local_enable=YES<br />
local_umask=022<br />
xferlog_enable=YES<br />
connect_from_port_20=YES<br />
xferlog_std_format=YES<br />
listen=YES<br />
write_enable=YES<br />
anon_upload_enable=YES<br />
anon_mkdir_write_enable=YES<br />
anon_other_write_enable=YES<br />
one_process_model=NO<br />
chroot_local_user=YES<br />
ftpd_banner=Welcom to my FTP server.<br />
anon_world_readable_only=NO<br />
guest_enable=YES<br />
guest_username=virtual_user<br />
pam_service_name=vsftp.vu</p>
<p>上面代码中，guest_enable=YES表示启用虚拟用户；guest_username=virtual则是将虚拟用户映射为本地用户，这样虚拟 用户登录后才能进入本地用户virtual的目录/ftpsite；pam_service_name=vsftp.vu指定PAM的配置文件为 vsftp.vu。</p>
<p>6．重新启动VSFTP：<br />
#service vsftpd restart</p>
<p>7．以虚拟用户gou（Linux中并无该账号）进行测试：</p>
<p># ftp 127.0.0.1<br />
Connected to 127.0.0.1 (127.0.0.1).<br />
220 Welcom to my FTP server.<br />
Name (127.0.0.1:root): gou<br />
331 Please specify the password.<br />
Password:<br />
230 Login successful. Have fun.<br />
Remote system type is UNIX.<br />
Using binary mode to transfer files.</p>
<p>在虚拟FTP服务器中，也可以对各个用户的权限进行设置。方法是在/etc/vsftpd.conf文件中添加如下一行：<br />
user_config_dir=用户配置文件目录</p>
<p>然后在用户配置文件目录下创建相应的用户配置文件，比如为上述名为gou的用户创建一个配置文件（假设配置文件目录为/etc/vsftpd_user_conf）：</p>
<p>#vi /etc/vsftpd_user_conf/gou<br />
write_enable=NO<br />
anono_upload_enable=NO</p>
<p>8.虚拟用户个人目录设置</p>
<p>大家可以发现，无论是哪个虚拟用户，登录后所在的目录都是/home/ftpsite，即都是guest用户的自家目录。下面，介绍如何为每个虚拟用户建立自家目录。<br />
一种作法是在虚拟用户的个人配置文件中使用local_root选项指定虚拟用户的自家目录。以gou为例，在第上步的基础上，首先/etc/vsftpd_user_conf/gou文件中加入：<br />
local_root=/home/ftpsite/gou</p>
<p>/home/ftpsite下新建gou目录，并将权限设为virtual_user：<br />
9.添加FTP用户的步骤</p>
<p>1.在account.txt中添加用户名和密码</p>
<p>2.运行如下命令,将用户名和密码添加到数据库中</p>
<p>db_load -T -t hash -f ./account.txt /etc/vsftpd/account.db</p>
<p>3.在/home/ftpsite中新建一个文件夹,与用户明相同</p>
<p>4.在vsftpd_user_conf文件夹下新建和用户名相同的文件,并在其中加入<br />
local_root=/home/ftpsite/用户名</p>
</div>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=688</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>nginx负载均衡upstream配置</title>
		<link>/?p=600</link>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Tue, 08 Jul 2014 02:39:54 +0000</pubDate>
				<category><![CDATA[工具]]></category>
		<category><![CDATA[nginx]]></category>
		<guid isPermaLink="false">/?p=600</guid>

					<description><![CDATA[nginx做为一个强大的反向代理、负载均衡和缓存已经被广泛使用，今特对其负载均衡upstream配置做一个总结 [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>nginx做为一个强大的反向代理、负载均衡和缓存已经被广泛使用，今特对其负载均衡upstream配置做一个总结:</p>
<p><span id="more-600"></span></p>
<p><strong>第一种：轮询</strong></p>
<div class="codecolorer-container text default" style="width: 435px; overflow: auto; white-space: nowrap;">
<div class="text codecolorer">upstream ijz{<br />
server 192.168.0.1:3000;<br />
server 192.168.0.1:3001;<br />
}</div>
</div>
<p><strong>第二种：权重</strong></p>
<div class="codecolorer-container text default" style="width: 435px; overflow: auto; white-space: nowrap;">
<div class="text codecolorer">upstream ijz{<br />
server 192.168.0.1 weight=2;<br />
server 192.168.0.2 weight=3;<br />
}</div>
</div>
<p>这种模式可解决服务器性能不等的情况下轮询比率的调配</p>
<p><strong>第三种：ip_hash</strong></p>
<div class="codecolorer-container text default" style="width: 435px; overflow: auto; white-space: nowrap;">
<div class="text codecolorer">upstream ijz{<br />
ip_hash;<br />
server 192.168.0.1;<br />
server 192.168.0.2;<br />
}</div>
</div>
<p>这种模式会根据来源IP和后端配置来做hash分配，确保固定IP只访问一个后端</p>
<p><strong>第四种：fair</strong></p>
<p>需要安装<a href="http://wiki.nginx.org/HttpUpstreamFairModule" target="_blank">Upstream Fair Balancer</a> Module</p>
<div class="codecolorer-container text default" style="width: 435px; overflow: auto; white-space: nowrap;">
<div class="text codecolorer">upstream ijz{<br />
server 192.168.0.1;<br />
server 192.168.0.2;<br />
fair;<br />
}</div>
</div>
<p>这种模式会根据后端服务的响应时间来分配，响应时间短的后端优先分配</p>
<p><strong>第五种：自定义hash</strong></p>
<p>需要安装<a href="http://wiki.nginx.org/HttpUpstreamRequestHashModule" target="_blank">Upstream Hash</a> Module</p>
<div class="codecolorer-container text default" style="width: 435px; overflow: auto; white-space: nowrap;">
<div class="text codecolorer">upstream ijz{<br />
server 192.168.0.1;<br />
server 192.168.0.2;<br />
hash $request_uri;<br />
}</div>
</div>
<p>这种模式可以根据给定的字符串进行Hash分配</p>
<p><strong>具体应用：</strong></p>
<div class="codecolorer-container text default" style="width: 435px; overflow: auto; white-space: nowrap;">
<div class="text codecolorer">server{<br />
listen 80;<br />
server_name .ijz.me;<br />
charset utf-8;location / {<br />
proxy_pass http://ijz/;<br />
}<br />
}</div>
</div>
<p>&nbsp;</p>
<p><strong>此外upstream每个后端的可设置参数为：</strong></p>
<p>1.down: 表示此台server暂时不参与负载。</p>
<p>2.weight: 默认为1，weight越大，负载的权重就越大。</p>
<p>3.max_fails: 允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误。</p>
<p>4.fail_timeout: max_fails次失败后，暂停的时间。</p>
<p>5.backup: 其它所有的非backup机器down或者忙的时候，请求backup机器，应急顶替。</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Subversion快速入门教程/zz/</title>
		<link>/?p=65</link>
					<comments>/?p=65#respond</comments>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 16:00:00 +0000</pubDate>
				<category><![CDATA[工具]]></category>
		<guid isPermaLink="false">/?p=65</guid>

					<description><![CDATA[如何快速建立Subversion服务器，并且在项目中使用起来，这是大家最关心的问题，与CVS相比，Subver [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>如何快速建立Subversion服务器，并且在项目中使用起来，这是大家最关心的问题，与CVS相比，Subversion有更多的选择，也更加的容易，几个命令就可以建立一套服务器环境，可以使用起来。</p>
<p>本文是使用Subversion最快速的教程，在最短的时间里帮助您建立起一套可用的服务器环境，只需略加调整就可以应用到实际项目当中。</p>
<p><span id="more-65"></span></p>
<p>本教程分为以下几个部门，不仅仅是快速入门，最后我们还有一些高级功能的说明，为了说明简单，教程是在windows下使用的方式，以方便资源有限的项目使用，对于UNIX环境下，区别并不大。</p>
<p>1，软件下载</p>
<p>下载Subversion服务器程序。</p>
<p>到 官方网站 的下载二进制安装文件，来到 二进制包下载部分 ，找到 Windows NT, 2000, XP and 2003部分，然后选择&#8221; this directory &#8220;，这样我们可以看到许多下载的内容，目前可以下栽 svn-1.2.3-setup.exe 。</p>
<p>下载Subversion的Windows客户端TortoiseSVN。</p>
<p>TortoiseSVN是扩展Windows Shell的一套工具，可以看作Windows资源管理器的插件，安装之后Windows就可以识别Subversion的工作目录。<br />
官方网站是 TortoiseSVN ，下载方式和前面的svn服务器类似，在 Download 页面的我们选择Official version for Win2k/X103fP or higher的版本，然后在sourceforge的　下载页面 选择目前的最高稳定版本的安装文件 TortoiseSVN-1.2.4.4479-svn-1.2.3.msi 。</p>
<p>2，服务器和客户端安装</p>
<p>服务器安装，直接运行 svn-1.2.3-setup.exe ，根据提示安装即可，这样我们就有了一套服务器可以运行的环境。</p>
<p>安装TortoiseSVN，同样直接运行 TortoiseSVN-1.2.4.4479-svn-1.2.3.msi 按照提示安装即可，不过最后完成后会提示是否重启，其实重启只是使svn工作拷贝在windows中的特殊样式生效，与所有的实际功能无关，这里为了立刻看到好的效果，还是重新启动机器。</p>
<p>3，建立版本库（Repository）</p>
<p>运行Subversion服务器需要首先要建立一个版本库（Repository），可以看作服务器上存放数据的数据库，在安装了Subversion服务器之后，可以直接运行，如：<br />
svnadmin create E:svndemorepository<br />
就会在目录E:svndemorepository下创建一个版本库。</p>
<p>我们也可以使用TortoiseSVN图形化的完成这一步：<br />
在目录E:svndemorepository下&#8221;右键-&gt;TortoiseSVN-&gt;Create Repository here&#8230;“， 然后可以选择版本库模式， 这里使用默认即可，然后就创建了一系列目录和文件。</p>
<p>4，配置用户和权限</p>
<p>来到E:svndemorepositoryconf目录，修改svnserve.conf：<br />
# [general]<br />
# password-db = passwd</p>
<p>改为：<br />
[general]<br />
password-db = passwd 然后修改同目录的passwd文件，去掉下面三行的注释：<br />
# [users]<br />
# harry = harryssecret<br />
# sally = sallyssecret</p>
<p>最后变成：<br />
[users]<br />
harry = harryssecret<br />
sally = sallyssecret</p>
<p>5，运行独立服务器</p>
<p>在任意目录下运行：<br />
svnserve -d -r E:svndemorepository 我们的服务器程序就已经启动了。</p>
<p>6，初始化导入</p>
<p>来到我们想要导入的项目根目录，在这个例子里是E:svndemoinitproject，目录下有一个readme.txt文件：</p>
<p>右键-&gt;TortoiseSVN-&gt;Import&#8230; URL of repository输入“svn://localhost/trunk” ok</p>
<p>完成之后目录没有任何变化，如果没有报错，数据就已经全部导入到了我们刚才定义的版本库中。</p>
<p>7，基本客户端操作</p>
<p>取出版本库到一个工作拷贝：</p>
<p>来到任意空目录下，在本例中是E:svndemowc1，运行右键-&gt;Checkout，在URL of repository中输入svn://localhost/trunk，这样我们就得到了一份工作拷贝。</p>
<p>在工作拷贝中作出修改并提交：</p>
<p>打开readme.txt，作出修改，然后右键-&gt;Commit&#8230;，这样我们就把修改提交到了版本库，我们可以运行。</p>
<p>察看所作的修改：</p>
<p>readme.txt上右键-&gt;TortoiseSVN-&gt;Show Log，这样我们就可以看到我们对这个文件所有的提交。在版本1上右键-&gt;Compare with working copy，我们可以比较工作拷贝的文件和版本1的区别。</p>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=65</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>svnserve 配置及权限管理/zz/</title>
		<link>/?p=66</link>
					<comments>/?p=66#respond</comments>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 16:00:00 +0000</pubDate>
				<category><![CDATA[工具]]></category>
		<guid isPermaLink="false">/?p=66</guid>

					<description><![CDATA[用SVN(Subversion)取代CVS的呼声越来越高。SVN也确实比CVS优胜很多，没有辜负众望。 在日常 [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>用SVN(Subversion)取代CVS的呼声越来越高。SVN也确实比CVS优胜很多，没有辜负众望。</p>
<p>在日常工作中，如何配置好和利用好SVN，是很值得花些时间去研究研究的。在我应用SVN的这段时间里，更喜欢的是用svnserve加客户端来搭配使用。</p>
<p>也就是将svnserve配置成为一个服务端，然后在Windows 下安装个TortoiseSVN 。这是一个不错的搭配选择。</p>
<p><span id="more-66"></span></p>
<p>1 SVN安装</p>
<p>1.1 FreeBSD下安装SVN</p>
<p>1.1.1 安装SVN</p>
<p># cd /usr/ports/devel/subversion<br />
# make NOPORTDOCS=YES -DWITH_SVNSERVE_WRAPPER install clean</p>
<p>1.1.2 创建用户</p>
<p># pw useradd -s /bin/sh -d /var/empty -n svn</p>
<p>1.2 Linux下安装SVN</p>
<p>1.2.1 下载及编译安装SVN</p>
<p># wget <a href="http://subversion.tigris.org/downloads/subversion-1.3.2.tar.bz2">http://subversion.tigris.org/downloads/subversion-1.3.2.tar.bz2</a><br />
# tar -jxvf subversion-1.3.2.tar.bz2<br />
# cd subversion-1.3.2<br />
# ./configure &#8211;with-zlib &#8211;enable-all-static</p>
<p>1.2.2 创建用户</p>
<p># useradd -d /var/empty svn</p>
<p>2 svnserve配置</p>
<p>2.1 创建仓库</p>
<p>2103f.1.1 创建仓库存放目录</p>
<p># mkdir -p /opt/svn/｛repos,etc}</p>
<p>2.1.2 创建SVN仓库</p>
<p># svnadmin create /opt/svn/repos/source1<br />
# svnadmin create /opt/svn/repos/source2<br />
# chown -R svn:svn /opt/svn/<br />
仓库名称可以根据自己的规划或喜好设定。</p>
<p>2.2 配置仓库</p>
<p>SVN的svnserve对于每个仓库，有一个独立的配置文件和独立的用户、权限管理。</p>
<p>在这里仍然要保持配置文件svnserve.conf的独立，但是用户、权限管理是用统一的一个文件来存储。这样方便以后的管理和维护。</p>
<p>另外要注意，即使svnserve服务已经运行，修改配置文件或者用户、权限管理文件，保存后马上生效，不需要重启服务。</p>
<p>2.2.1 配置source1仓库</p>
<p>进入仓库目录</p>
<p># cd /opt/svn/repos/source1</p>
<p>2.2.2 修改配置</p>
<p>你可以直接删除默认的svnserve.conf文件，然后使用下面的配置：</p>
<p># vi svnserve.conf<br />
[general]<br />
anon-access = none<br />
auth-access = write<br />
password-db = /opt/svn/etc/svn-user.conf<br />
authz-db = /opt/svn/etc/svn-authz.conf<br />
realm = My First Repository<br />
说明：</p>
<p>anon-access = none #不允许匿名用户访问<br />
auth-access = write #通过验证的用户可以读和写<br />
password-db = /opt/svn/etc/svn-user.conf #用户保存文件<br />
authz-db = /opt/svn/etc/svn-authz.conf #权限管理文件<br />
realm = My First Repository #仓库名称</p>
<p>2.2.3 配置source2仓库</p>
<p># cd /opt/svn/repos/source2</p>
<p>2.2.4 修改配置</p>
<p>你可以直接删除默认的svnserve.conf文件，然后使用下面的配置：</p>
<p># vi svnserve.conf<br />
[general]<br />
anon-access = none<br />
auth-access = write<br />
password-db = /opt/svn/etc/svn-user.conf<br />
authz-db = /opt/svn/etc/svn-authz.conf<br />
realm = My Second Repository<br />
如果有更多的仓库，可以类推配置。</p>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
svnserve.conf的原始内容：</p>
<p>### This file controls the configuration of the svnserve daemon, if you<br />
### use it to allow access to this repository. (If you only allow<br />
### access through http: and/or file: URLs, then this file is<br />
### irrelevant.)</p>
<p>### Visit <a href="http://subversion.tigris.org/">http://subversion.tigris.org/</a> for more information.</p>
<p>[general]<br />
### These options control access to the repository for unauthenticated<br />
### and authenticated users. Valid values are &#8220;write&#8221;, &#8220;read&#8221;,<br />
### and &#8220;none&#8221;. The sample settings below are the defaults.<br />
# anon-access = read<br />
# auth-access = write<br />
### The password-db option controls the location of the password<br />
### database file. Unless you specify a path starting with a /,<br />
### the file&#8217;s location is relative to the conf directory.<br />
### Uncomment the line below to use the default password file.<br />
# password-db = passwd<br />
### The authz103f-db option controls the location of the authorization<br />
### rules for path-based access control. Unless you specify a path<br />
### starting with a /, the file&#8217;s location is relative to the conf<br />
### directory. If you don&#8217;t specify an authz-db, no path-based access<br />
### control is done.<br />
### Uncomment the line below to use the default authorization file.<br />
# authz-db = authz<br />
### This option specifies the authentication realm of the repository.<br />
### If two repositories have the same authentication realm, they should<br />
### have the same password database, and vice versa. The default realm<br />
### is repository&#8217;s uuid.<br />
# realm = My First Repository<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
3 用户及权限管理</p>
<p>3.1 用户管理</p>
<p>3.1.1 创建用户存储文件</p>
<p># vi /opt/svn/etc/svn-user.conf</p>
<p>3.1.2 设置用户帐号</p>
<p>[users]<br />
harry = harryssecret<br />
sally = sallyssecret<br />
bote = botessecret<br />
说明：</p>
<p>[users] #是必须的，标记为用户配置开始<br />
harry = harryssecret # harry 是用户名 ， harryssecret是密码。注意，是明文密码<br />
sally = sallyssecret # 同上<br />
bote = botessecret # 同上<br />
往后所以仓库的用户都在这里记录就可以了。至于那个用户，允许访问那个仓库，在权限管理里限制。</p>
<p>3.2 权限管理</p>
<p>3.2.1 创建权限管理文件</p>
<p># vi /opt/svn/etc/svn-authz.conf</p>
<p>3.2.1 设置权限管理</p>
<p>[groups]<br />
source1 = harry<br />
source2 = sally</p>
<p>[source1:/]<br />
@source1 = rw<br />
@source2 = r</p>
<p>[source2:/]<br />
@source2 = rw<br />
bote = rw</p>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=66</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>SVN在windows平台上的配置/zz/</title>
		<link>/?p=67</link>
					<comments>/?p=67#respond</comments>
		
		<dc:creator><![CDATA[桔子]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 16:00:00 +0000</pubDate>
				<category><![CDATA[工具]]></category>
		<guid isPermaLink="false">/?p=67</guid>

					<description><![CDATA[下载。到官方网站（http://subversion.tigris.org）下载1.4.5的windows安装 [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>下载。到官方网站（<a href="http://subversion.tigris.org/">http://subversion.tigris.org</a>）下载1.4.5的windows安装版。</p>
<p>安装。一路Next到底。</p>
<p>创建项目。</p>
<p>打开命令窗口（运行－cmd） 。</p>
<p>输入命令：</p>
<p>svnadmin create e:svnFianceTemplateV2</p>
<p><span id="more-67"></span></p>
<p>完了，在E:svn下会建立FianceTemplateV2文件夹，并且文件夹结构如图：</p>
<p><img loading="lazy" decoding="async" src="http://image.it168.com/cms/2008-6-2/Image/200862231719.jpg" alt="" width="492" height="314" /></p>
<p>打开E:svnFianceTemplateV2conf下的svnserve.conf文件，找到以下几句：</p>
<p># anon-access = read<br />
# auth-access = write<br />
# password-db = passwd<br />
# authz-db = authz</p>
<p>去掉每行前的#号。第一行表示默认权限为只读，第二行表示授权以后访问权限为可写，第三行表示记录用户名密码信息的文件是passwd文件，也可以是 passwd.db等文件，一定要跟文件名保持一致，第四行表示记录用户授权信息的文件是authz文件，其他跟passwd类似。</p>
<p>打开passwd文件，将</p>
<p>[users]<br />
# harry = harryssecret<br />
# sally = sallyssecret</p>
<p>将每行前面的#号去掉，</p>
]]></content:encoded>
					
					<wfw:commentRss>/?feed=rss2&#038;p=67</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
